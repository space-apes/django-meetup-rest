from django.test import TestCase, Client
from django.urls import reverse
from api.models import *
import logging

# Create your tests here.

#TODO Model Tests
#TODO Serializer/Validator Tests
#TODO Endpoint/Permissions Tests


#ENDPOINT/PERMISSIONS TESTS####################################################################
anonymous_credential_data = {}
valid_user_credential_data =  {'username':'ftester', 'password':'password'}
invalid_user_credential_data =  {'username':'dtester', 'password':'password'}
superuser_credential_data =  {'username':'root', 'password':'password'}

class acquireTokenTestCase(TestCase):
    """separate test case to acquire tokens since all endpoint tests depend on getting token. 
        - test that anonymous users can NOT acquire a token
        - test that both authenticated users CAN acquire a token
        - test that super user CAN acquire a token
    """
    def test_anonymous_can_not_get_token(self):
        response = Client().post(
                reverse('token-obtain-pair'),
                anonymous_credential_data,
                Content_type="application/json"
                )
        self.assertEqual(response.status_code, 400)
        self.assertFalse('access' in response.data.keys())
	
    def test_valid_authenticated_can_get_token(self):
        response = Client().post(reverse('token-obtain-pair'),
                valid_user_credential_data,
                Content_type="application/json"
                )
        self.assertEqual(response.status_code, 200)
        self.assertTrue('access' in response.data.keys())

    def test_invalid_authenticated_can_get_token(self):
        response = Client().post(reverse('token-obtain-pair'),
                self.invalid_user_credential_data,
                Content_type="application/json"
                )
        self.assertEqual(response.status_code, 200)
        self.assertTrue('access' in response.data.keys())

    def test_superuser_can_get_token(self):
        response = Client().post(reverse('token-obtain-pair'),
                superuser_credential_data,
                Content_type="application/json"
                )
        self.assertEqual(response.status_code, 200)
        self.assertTrue('access' in response.data.keys())


class EndpointTestCase(TestCase):
    """an abstract parent class for all endpoint tests
        - gets tokens for all types of authenticated users
        - 'declares prototype methods' for each test that should be run on endpoint
    """
    def setUp(self):
        """
            acquire jwt tokens for anonymous,valid,invalid,and super users
        """
        #no token available for anonymous users
        self.anonymous_access_token = ""
        self.valid_user_access_token = Client().post(
                reverse('token_obtain_pair'),
                valid_user_credential_data,
                'application/json').data['access']

        self.invalid_user_access_token = Client().post(
                reverse('token_obtain_pair'),
                invalid_user_credential_data,
                'application/json').data['access']

        self.superuser_access_token = Client().post(
                reverse('token_obtain_pair'),
                superuser_credential_data,
                'application/json').data['access']

    def get_response(self, user_type, http_method, base_url, slug="", data=None):
        """
            helper function to get response object. 
            allows us to specify user from a couple categories of users
            fetches associated jwt token
            checks for invalid http methods

            PARAMETERS:
            ----------
                - str user_type : set type of user for request
                    - from options {'anon', 'valid', 'invalid', 'super'}
                    - pulls username and password from global variables
                        - valid_user_credential_data
                        - invalid_user_credential_data
                        - superuser_credential_data
                - str http_method : {"get", "post", "put", "patch", "delete"}
                - str base_url : api endpoint like '/api/users/'
                - str slug : optional slug to append to base-name when accessing individual
                - dict data : optional data to pass in for post,put,patch 
            RETURNS:
            --------
                - django.http.response response : response object
        """
    
        if user_type not in ['anon','valid', 'invalid', 'super']:
            logger.error('invalid user_type')
            return None
        tokenDict = {
                "anon":self.anonymous_access_token,
                "valid":self.valid_user_access_token,
                "invalid":self.invalid_user_access_token,
                "super":self.superuser_access_token
                }
        token = tokenDict[user_type]

        if http_method not in ['get', 'post', 'put', 'patch', 'delete']:
            logger.error('invalid http_method')
            return None
        
        if http_method == 'get':
            return Client().get(
                    base_url+slug,
                    HTTP_AUTHORIZATION="Bearer "+token
                    )

        elif http_method == 'post':
            if not data:
                logger.error('post needs data')
                return None
            return Client().post(
                    base_url+slug,
                    data,
                    HTTP_AUTHORIZATION="Bearer "+token,
                    CONTENT_TYPE="application/json"
                    )
        elif http_method == 'put':
            if not data:
                logger.error('put needs data')
                return None
            return Client().put(
                    base_url+slug,
                    data,
                    HTTP_AUTHORIZATION="Bearer "+token,
                    CONTENT_TYPE="application/json"
                    )

        elif http_method == 'patch':
            if not data:
                logger.error('patch needs data')
                return None
            return Client().patch(
                    base_url+slug,
                    data,
                    HTTP_AUTHORIZATION="Bearer "+token,
                    CONTENT_TYPE="application/json"
                    )

        elif http_method == 'delete':
            return Client().delete(
                    base_url+slug,
                    HTTP_AUTHORIZATION="Bearer "+token
                    )
        else:
            logger.error('invalid http method')
            return None

    def test_anonymous_get_list(self):
        pass
    def test_anonymous_get_detail(self):
        pass
    def test_anonymous_post(self):
        pass
    def test_anonymous_put(self):
        pass
    def test_anonymous_patch(self):
        pass
    def test_anonymous_delete(self):
        pass

    def test_valid_get_list(self):
        pass
    def test_valid_get_detail(self):
        pass
    def test_valid_post(self):
        pass
    def test_valid_put(self):
        pass
    def test_valid_patch(self):
        pass
    def test_valid_delete(self):
        pass

    def test_invalid_get_list(self):
        pass
    def test_invalid_get_detail(self):
        pass
    def test_invalid_post(self):
        pass
    def test_invalid_put(self):
        pass
    def test_invalid_patch(self):
        pass
    def test_invalid_delete(self):
        pass

    def test_super_get_list(self):
        pass
    def test_super_get_detail(self):
        pass
    def test_super_post(self):
        pass
    def test_super_put(self):
        pass
    def test_super_patch(self):
        pass
    def test_super_delete(self):
        pass

class UsersEndpointTestCase(EndpointTestCase):
    def setUp(self):
        self.base_url = '/api/users/'
        self.valid_slug = User.objects.get(username=valid_user_credential_data['username']).id+'/'

    def test_anonymous_get_list(self):
        response = self.get_response(
                user_type='anon',
                http_method='get',
                base_url=self.base_url,
                slug="",
                data=None
                )
        self.assertEqual(response.status_code, 401)
    def test_anonymous_get_detail(self):
        pass
    def test_anonymous_post(self):
        pass
    def test_anonymous_put(self):
        pass
    def test_anonymous_patch(self):
        pass
    def test_anonymous_delete(self):
        pass

    def test_valid_get_list(self):
        pass
    def test_valid_get_detail(self):
        pass
    def test_valid_post(self):
        pass
    def test_valid_put(self):
        pass
    def test_valid_patch(self):
        pass
    def test_valid_delete(self):
        pass

    def test_invalid_get_list(self):
        pass
    def test_invalid_get_detail(self):
        pass
    def test_invalid_post(self):
        pass
    def test_invalid_put(self):
        pass
    def test_invalid_patch(self):
        pass
    def test_invalid_delete(self):
        pass

    def test_super_get_list(self):
        pass
    def test_super_get_detail(self):
        pass
    def test_super_post(self):
        pass
    def test_super_put(self):
        pass
    def test_super_patch(self):
        pass
    def test_super_delete(self):
        pass


            
